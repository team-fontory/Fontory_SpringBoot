package org.fontory.fontorybe.unit.mock;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import org.fontory.fontorybe.bookmark.domain.Bookmark;
import org.fontory.fontorybe.bookmark.service.port.BookmarkRepository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;

public class FakeBookmarkRepository implements BookmarkRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(1);
    private final List<Bookmark> data = new ArrayList<>();

    @Override
    public Bookmark save(Bookmark bookmark) {
        if (bookmark.getId() == null) {
            // Create new bookmark
            Bookmark newBookmark = Bookmark.builder()
                    .id(autoGeneratedId.getAndIncrement())
                    .memberId(bookmark.getMemberId())
                    .fontId(bookmark.getFontId())
                    .createdAt(LocalDateTime.now())
                    .updatedAt(LocalDateTime.now())
                    .build();
            data.add(newBookmark);
            return newBookmark;
        } else {
            // Update existing bookmark
            data.removeIf(item -> item.getId().equals(bookmark.getId()));
            Bookmark updatedBookmark = Bookmark.builder()
                    .id(bookmark.getId())
                    .memberId(bookmark.getMemberId())
                    .fontId(bookmark.getFontId())
                    .createdAt(bookmark.getCreatedAt())
                    .updatedAt(LocalDateTime.now())
                    .build();
            data.add(updatedBookmark);
            return updatedBookmark;
        }
    }

    @Override
    public boolean existsByMemberIdAndFontId(Long memberId, Long fontId) {
        return data.stream()
                .anyMatch(bookmark -> bookmark.getMemberId().equals(memberId) && 
                         bookmark.getFontId().equals(fontId));
    }

    @Override
    public Optional<Bookmark> findByMemberIdAndFontId(Long memberId, Long fontId) {
        return data.stream()
                .filter(bookmark -> bookmark.getMemberId().equals(memberId) && 
                       bookmark.getFontId().equals(fontId))
                .findFirst();
    }

    @Override
    public void deleteById(Long id) {
        data.removeIf(bookmark -> bookmark.getId().equals(id));
    }

    @Override
    public Page<Bookmark> findAllByMemberId(Long memberId, PageRequest pageRequest) {
        List<Bookmark> filtered = data.stream()
                .filter(bookmark -> bookmark.getMemberId().equals(memberId))
                .sorted((b1, b2) -> {
                    if (pageRequest.getSort().isSorted()) {
                        // Assuming descending order by createdAt
                        return b2.getCreatedAt().compareTo(b1.getCreatedAt());
                    }
                    return 0;
                })
                .collect(Collectors.toList());

        int start = (int) pageRequest.getOffset();
        int end = Math.min(start + pageRequest.getPageSize(), filtered.size());
        
        List<Bookmark> pageContent = filtered.subList(start, end);
        return new PageImpl<>(pageContent, pageRequest, filtered.size());
    }

    // Helper methods for testing
    public List<Bookmark> findAll() {
        return new ArrayList<>(data);
    }

    public void clear() {
        data.clear();
        autoGeneratedId.set(1);
    }

    public Optional<Bookmark> findById(Long id) {
        return data.stream()
                .filter(bookmark -> bookmark.getId().equals(id))
                .findFirst();
    }
}