package org.fontory.fontorybe.unit.mock;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import org.fontory.fontorybe.font.domain.Font;
import org.fontory.fontorybe.font.infrastructure.entity.FontStatus;
import org.fontory.fontorybe.font.service.port.FontRepository;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;

public class FakeFontRepository implements FontRepository {
    private final AtomicLong autoGeneratedId = new AtomicLong(1);
    private final List<Font> data = new ArrayList<>();

    @Override
    public Font save(Font font) {
        if (font.getId() == null) {
            // Create new font
            Font newFont = Font.builder()
                    .id(autoGeneratedId.getAndIncrement())
                    .name(font.getName())
                    .engName(font.getEngName())
                    .status(font.getStatus())
                    .example(font.getExample())
                    .downloadCount(font.getDownloadCount() != null ? font.getDownloadCount() : 0L)
                    .bookmarkCount(font.getBookmarkCount() != null ? font.getBookmarkCount() : 0L)
                    .key(font.getKey())
                    .memberId(font.getMemberId())
                    .createdAt(LocalDateTime.now())
                    .updatedAt(LocalDateTime.now())
                    .build();
            data.add(newFont);
            return newFont;
        } else {
            // Update existing font
            data.removeIf(item -> item.getId().equals(font.getId()));
            Font updatedFont = Font.builder()
                    .id(font.getId())
                    .name(font.getName())
                    .engName(font.getEngName())
                    .status(font.getStatus())
                    .example(font.getExample())
                    .downloadCount(font.getDownloadCount())
                    .bookmarkCount(font.getBookmarkCount())
                    .key(font.getKey())
                    .memberId(font.getMemberId())
                    .createdAt(font.getCreatedAt())
                    .updatedAt(LocalDateTime.now())
                    .build();
            data.add(updatedFont);
            return updatedFont;
        }
    }

    @Override
    public List<Font> findTop10ByMemberIdOrderByCreatedAtDesc(Long memberId) {
        return data.stream()
                .filter(font -> font.getMemberId().equals(memberId))
                .sorted((f1, f2) -> f2.getCreatedAt().compareTo(f1.getCreatedAt()))
                .limit(10)
                .collect(Collectors.toList());
    }

    @Override
    public Optional<Font> findById(Long id) {
        return data.stream()
                .filter(font -> font.getId().equals(id))
                .findFirst();
    }

    @Override
    public Page<Font> findAllByMemberIdAndStatus(Long memberId, PageRequest pageRequest, FontStatus status) {
        List<Font> filtered = data.stream()
                .filter(font -> font.getMemberId().equals(memberId) && font.getStatus().equals(status))
                .collect(Collectors.toList());
        
        int start = (int) pageRequest.getOffset();
        int end = Math.min(start + pageRequest.getPageSize(), filtered.size());
        
        List<Font> pageContent = filtered.subList(start, end);
        return new PageImpl<>(pageContent, pageRequest, filtered.size());
    }

    @Override
    public void deleteById(Long id) {
        data.removeIf(font -> font.getId().equals(id));
    }

    @Override
    public Page<Font> findAllByStatus(PageRequest pageRequest, FontStatus status) {
        List<Font> filtered = data.stream()
                .filter(font -> font.getStatus().equals(status))
                .collect(Collectors.toList());
        
        int start = (int) pageRequest.getOffset();
        int end = Math.min(start + pageRequest.getPageSize(), filtered.size());
        
        List<Font> pageContent = filtered.subList(start, end);
        return new PageImpl<>(pageContent, pageRequest, filtered.size());
    }

    @Override
    public Page<Font> findByNameContainingAndStatus(String keyword, PageRequest pageRequest, FontStatus status) {
        List<Font> filtered = data.stream()
                .filter(font -> font.getStatus().equals(status) && font.getName().contains(keyword))
                .collect(Collectors.toList());
        
        int start = (int) pageRequest.getOffset();
        int end = Math.min(start + pageRequest.getPageSize(), filtered.size());
        
        List<Font> pageContent = filtered.subList(start, end);
        return new PageImpl<>(pageContent, pageRequest, filtered.size());
    }

    @Override
    public List<Font> findTop3ByMemberIdAndIdNotAndStatusOrderByCreatedAtDesc(Long memberId, Long fontId, FontStatus status) {
        return data.stream()
                .filter(font -> font.getMemberId().equals(memberId) && 
                               !font.getId().equals(fontId) && 
                               font.getStatus().equals(status))
                .sorted((f1, f2) -> f2.getCreatedAt().compareTo(f1.getCreatedAt()))
                .limit(3)
                .collect(Collectors.toList());
    }

    @Override
    public List<Font> findAllByIdIn(List<Long> ids) {
        // Maintain the order of IDs as provided
        return ids.stream()
                .map(id -> data.stream()
                        .filter(font -> font.getId().equals(id))
                        .findFirst()
                        .orElse(null))
                .filter(font -> font != null)
                .collect(Collectors.toList());
    }

    @Override
    public List<Font> findTop4ByMemberIdAndStatusOrderByDownloadAndBookmarkCountDesc(Long memberId, FontStatus status) {
        return data.stream()
                .filter(font -> font.getMemberId().equals(memberId) && font.getStatus().equals(status))
                .sorted((f1, f2) -> {
                    long total1 = f1.getDownloadCount() + f1.getBookmarkCount();
                    long total2 = f2.getDownloadCount() + f2.getBookmarkCount();
                    return Long.compare(total2, total1);
                })
                .limit(4)
                .collect(Collectors.toList());
    }

    @Override
    public List<Font> findTop3ByStatusOrderByDownloadAndBookmarkCountDesc(FontStatus status) {
        return data.stream()
                .filter(font -> font.getStatus().equals(status))
                .sorted((f1, f2) -> {
                    long total1 = f1.getDownloadCount() + f1.getBookmarkCount();
                    long total2 = f2.getDownloadCount() + f2.getBookmarkCount();
                    return Long.compare(total2, total1);
                })
                .limit(3)
                .collect(Collectors.toList());
    }

    @Override
    public boolean existsByName(String fontName) {
        return data.stream()
                .anyMatch(font -> font.getName().equals(fontName));
    }
    
    @Override
    public boolean existsByMemberIdAndName(Long memberId, String fontName) {
        return data.stream()
                .anyMatch(font -> font.getMemberId().equals(memberId) && font.getName().equals(fontName));
    }

    // Helper methods for testing
    public List<Font> findAll() {
        return new ArrayList<>(data);
    }

    public void clear() {
        data.clear();
        autoGeneratedId.set(1);
    }
}